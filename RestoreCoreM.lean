import Lean
import Duper.Tactic
import Duper.TPTP
open Lean
-- Desperate time, desperate measures
-- This file is generated by RestoreCoreMCodeGen.lean

-- Names being added:
  -- Duper.clausify_not
  -- Duper.exists_hoist_proof
  -- Duper.rule20Theorem
  -- Duper.clausify_and_false
  -- Duper.c1_soundness
  -- Duper.clausify_or_false_right
  -- Duper.clausify_imp
  -- Duper.true_ne_false
  -- Duper.clausify_prop_inequality1
  -- optParam
  -- Duper.bool_false_ne_true
  -- Nonempty
  -- Duper.rule6Theorem
  -- Duper.rule28Theorem
  -- Duper.prop_true_ne_false
  -- Duper.rule15Theorem
  -- Eq
  -- Duper.of_not_eq_false
  -- Iff
  -- Duper.rule12Theorem
  -- Bool.true
  -- Duper.rule21Theorem
  -- Duper.rule3Theorem
  -- Duper.exists_of_forall_eq_false
  -- Duper.equality_factoring_soundness4
  -- Subtype
  -- Duper.rule14Theorem
  -- Duper.eq_hoist_proof
  -- Ne
  -- Duper.clausify_and_right
  -- Or
  -- Duper.rule5Theorem
  -- Duper.clausify_and_left
  -- Setoid.refl
  -- Duper.loob_hoist_proof
  -- Duper.not_of_eq_false
  -- Duper.forall_hoist_proof
  -- Duper.bool_true_ne_false
  -- Duper.clausify_not_false
  -- Duper.rule10Theorem
  -- Duper.rule22Theorem
  -- And
  -- eq_true
  -- Duper.false_neq_true
  -- Setoid
  -- Duper.rule13SymTheorem
  -- Duper.rule2Theorem
  -- of_eq_true
  -- Duper.true_neq_false
  -- Not
  -- congrArg
  -- Duper.c2_soundness
  -- congrFun
  -- Duper.prop_false_ne_true
  -- Duper.rule6SymTheorem
  -- Exists
  -- Duper.rule11SymTheorem
  -- instHasEquiv
  -- Duper.rule11Theorem
  -- Subtype.eq
  -- sorryAx
  -- Iff.refl
  -- Duper.rule2SymTheorem
  -- Iff.rfl
  -- Subtype.val
  -- Duper.rule16Theorem
  -- Duper.rule1Theorem
  -- Duper.equality_factoring_soundness1
  -- Duper.equality_factoring_soundness3
  -- Duper.clausify_imp_false_right
  -- Duper.clausify_or_false_left
  -- True
  -- Duper.bool_hoist_proof
  -- TPTP.iota
  -- Duper.rule19Theorem
  -- false_ne_true
  -- Duper.nonempty_of_forall_eq_false
  -- Duper.rule10SymTheorem
  -- Duper.rule8Theorem
  -- Duper.rule23Theorem
  -- Duper.rule4SymTheorem
  -- Duper.rule9SymTheorem
  -- Duper.false_ne_true
  -- Duper.rule9Theorem
  -- Duper.rule24Theorem
  -- Duper.rule4Theorem
  -- Duper.fluid_loob_hoist_proof
  -- Duper.ne_hoist_proof
  -- Duper.rule13Theorem
  -- False
  -- nonempty_of_exists
  -- Duper.clausify_prop_inequality2
  -- Duper.rule7Theorem
  -- Duper.clausify_forall
  -- Duper.clausify_imp_false_left
  -- Duper.clausify_or
  -- Duper.rule18Theorem
  -- Duper.clausify_iff2
  -- Duper.rule3SymTheorem
  -- Bool.of_not_eq_false
  -- Duper.rule17Theorem
  -- true_ne_false
  -- Duper.clausify_iff1
  -- Duper.clausify_exists_false
  -- Duper.clausify_not_iff1
  -- HasEquiv
  -- Duper.nonempty_of_exists
  -- Duper.fluid_bool_hoist_proof
  -- Bool.false
  -- Bool
  -- HasEquiv.Equiv
  -- Duper.clausify_not_iff2
  -- Duper.equality_factoring_soundness2
def restoreCoreM : CoreM Unit := do
  let mut env ← getEnv
  if let none := env.find? `Duper.clausify_not then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.exists_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.exists_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 3) (Expr.bvar 2))) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule20Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule20Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.const `Not []) (Expr.bvar 1)) BinderInfo.default)) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.c1_soundness then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.c1_soundness, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or_false_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or_false_right, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_prop_inequality1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_prop_inequality1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `optParam then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `optParam, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.param `u)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.bool_false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.false [])) (Expr.const `Bool.true [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Nonempty then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Nonempty, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.zero)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule6Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule6Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `True []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule28Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule28Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0))) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.prop_true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.prop_true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule15Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule15Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Eq then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Eq, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.of_not_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.of_not_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `False [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule12Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule12Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Bool.true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.true, levelParams := [], type := Expr.const `Bool [], isUnsafe := false})
  if let none := env.find? `Duper.rule21Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule21Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.app (Expr.const `Not []) (Expr.bvar 0)) (Expr.bvar 1) BinderInfo.default)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule3Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule3Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.const `True []))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.exists_of_forall_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.exists_of_forall_eq_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.const `Not []) (Expr.app (Expr.bvar 2) (Expr.bvar 0))) BinderInfo.default)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness4 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness4, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.sort (Level.max (Level.succ (Level.zero)) (Level.param `u))) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule14Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule14Theorem, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.const `True []))) (Expr.const `False []), isUnsafe := false})
  if let none := env.find? `Duper.eq_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.eq_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Ne then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Ne, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_right, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Or then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Or, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule5Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule5Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_and_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_and_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Setoid.refl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Setoid.refl, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Setoid [Level.param `u]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.app (Expr.app (Expr.app (Expr.const `HasEquiv.Equiv [Level.param `u, Level.zero]) (Expr.bvar 2)) (Expr.app (Expr.app (Expr.const `instHasEquiv [Level.param `u]) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.loob_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.loob_hoist_proof, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.bvar 1) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 2) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.not_of_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.not_of_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `False [])) (Expr.app (Expr.const `Not []) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.forall_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.forall_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 3) (Expr.bvar 2))) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.bool_true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_true_ne_false, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.true [])) (Expr.const `Bool.false [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_false, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule10Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule10Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.const `True []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule22Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule22Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `And then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `And, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `eq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `eq_true, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.false_neq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.false_neq_true, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Setoid then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Setoid, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.max (Level.succ (Level.zero)) (Level.param `u))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule13SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule13SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.bvar 0))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule2Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule2Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `of_eq_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `of_eq_true, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `True [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.true_neq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.true_neq_false, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False []), isUnsafe := false})
  if let none := env.find? `Not then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Not, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `congrArg then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `congrArg, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.sort (Level.param `v)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 3) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `v]) (Expr.bvar 4)) (Expr.app (Expr.bvar 1) (Expr.bvar 3))) (Expr.app (Expr.bvar 1) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.c2_soundness then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.c2_soundness, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `congrFun then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `congrFun, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.param `v)) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.imax (Level.param `u) (Level.param `v)]) (Expr.forallE `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 4) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `v]) (Expr.app (Expr.bvar 4) (Expr.bvar 0))) (Expr.app (Expr.bvar 3) (Expr.bvar 0))) (Expr.app (Expr.bvar 2) (Expr.bvar 0))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.prop_false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.prop_false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule6SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule6SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Exists, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.sort (Level.zero)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule11SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule11SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.const `False [])) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `instHasEquiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `instHasEquiv, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `Setoid [Level.param `u]) (Expr.bvar 0)) (Expr.app (Expr.const `HasEquiv [Level.param `u, Level.zero]) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule11Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule11Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.const `False []))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype.eq then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype.eq, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.param `u))) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.app (Expr.app (Expr.app (Expr.const `Subtype.val [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Subtype.val [Level.succ (Level.param `u)]) (Expr.bvar 3)) (Expr.lam `_ (Expr.bvar 3) (Expr.app (Expr.bvar 3) (Expr.bvar 0)) BinderInfo.default)) (Expr.bvar 0))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.param `u)]) (Expr.app (Expr.app (Expr.const `Subtype [Level.succ (Level.param `u)]) (Expr.bvar 4)) (Expr.lam `_ (Expr.bvar 4) (Expr.app (Expr.bvar 4) (Expr.bvar 0)) BinderInfo.default))) (Expr.bvar 2)) (Expr.bvar 1)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `sorryAx then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `sorryAx, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `optParam [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.const `Bool.false [])) (Expr.bvar 1) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff.refl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff.refl, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule2SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule2SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Iff.rfl then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Iff.rfl, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 0)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Subtype.val then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Subtype.val, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Subtype [Level.param `u]) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.bvar 2) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule16Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule16Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.const `True []) (Expr.bvar 1) BinderInfo.default)) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule1Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule1Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness3 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness3, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp_false_right then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp_false_right, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or_false_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or_false_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `True then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `True, levelParams := [], type := Expr.sort (Level.zero), isUnsafe := false})
  if let none := env.find? `Duper.bool_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.bool_hoist_proof, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.bvar 1) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 2) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `TPTP.iota then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `TPTP.iota, levelParams := [], type := Expr.sort (Level.succ (Level.zero)), isUnsafe := false})
  if let none := env.find? `Duper.rule19Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule19Theorem, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.const `True []) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `false_ne_true, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Duper.nonempty_of_forall_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.nonempty_of_forall_eq_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.const `Nonempty [Level.param `u_1]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule10SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule10SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.const `True [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule8Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule8Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule23Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule23Theorem, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.app (Expr.const `And []) (Expr.app (Expr.bvar 0) (Expr.const `True []))) (Expr.app (Expr.bvar 0) (Expr.const `False [])))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule4SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule4SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.const `False [])) (Expr.bvar 0))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule9SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule9SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.bvar 0)) (Expr.app (Expr.const `Not []) (Expr.bvar 0)))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.false_ne_true then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.false_ne_true, levelParams := [], type := Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `False [])) (Expr.const `True [])) (Expr.const `False []) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule9Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule9Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `And []) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) (Expr.bvar 0))) (Expr.const `False [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule24Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule24Theorem, levelParams := [], type := Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.lam `_ (Expr.sort (Level.zero)) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 0) (Expr.const `True []))) (Expr.app (Expr.bvar 0) (Expr.const `False [])))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule4Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule4Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 0)) (Expr.const `False []))) (Expr.bvar 0)) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.fluid_loob_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.fluid_loob_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 2) (Expr.app (Expr.bvar 0) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 3) (Expr.app (Expr.bvar 1) (Expr.const `True [])))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.ne_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.ne_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 0) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.param `u_1]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 1) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.param `u_1]) (Expr.bvar 4)) (Expr.bvar 3)) (Expr.bvar 2))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule13Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule13Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 0)) (Expr.const `False []))) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `False then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `False, levelParams := [], type := Expr.sort (Level.zero), isUnsafe := false})
  if let none := env.find? `nonempty_of_exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `nonempty_of_exists, levelParams := [`u], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.const `Exists [Level.param `u]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default)) (Expr.app (Expr.const `Nonempty [Level.param `u]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_prop_inequality2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_prop_inequality2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.bvar 0)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule7Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule7Theorem, levelParams := [], type := Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.const `Not []) (Expr.const `False []))) (Expr.const `True []), isUnsafe := false})
  if let none := env.find? `Duper.clausify_forall then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_forall, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default)) (Expr.const `True [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 2) (Expr.bvar 1))) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_imp_false_left then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_imp_false_left, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 1) (Expr.bvar 1) BinderInfo.default)) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True [])) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_or then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_or, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule18Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule18Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.const `False []) BinderInfo.default)) (Expr.app (Expr.const `Not []) (Expr.bvar 0))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_iff2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_iff2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule3SymTheorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule3SymTheorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.const `True [])) (Expr.bvar 0))) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Bool.of_not_eq_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.of_not_eq_false, levelParams := [], type := Expr.forallE `_ (Expr.const `Bool []) (Expr.forallE `_ (Expr.app (Expr.const `Not []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.bvar 0)) (Expr.const `Bool.false []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.const `Bool [])) (Expr.bvar 1)) (Expr.const `Bool.true [])) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.rule17Theorem then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.rule17Theorem, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.forallE `_ (Expr.const `False []) (Expr.bvar 1) BinderInfo.default)) (Expr.const `True [])) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `true_ne_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `true_ne_false, levelParams := [], type := Expr.app (Expr.const `Not []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.const `True [])) (Expr.const `False [])), isUnsafe := false})
  if let none := env.find? `Duper.clausify_iff1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_iff1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `True [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_exists_false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_exists_false, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 2)) (Expr.lam `_ (Expr.bvar 2) (Expr.app (Expr.bvar 2) (Expr.bvar 0)) BinderInfo.default))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.bvar 2) (Expr.bvar 1))) (Expr.const `False [])) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_iff1 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_iff1, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `False []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `False []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `HasEquiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HasEquiv, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.sort (Level.max (Level.param `u) (Level.succ (Level.param `v)))) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.nonempty_of_exists then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.nonempty_of_exists, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Exists [Level.param `u_1]) (Expr.bvar 1)) (Expr.lam `_ (Expr.bvar 1) (Expr.app (Expr.bvar 1) (Expr.bvar 0)) BinderInfo.default))) (Expr.const `True [])) (Expr.app (Expr.const `Nonempty [Level.param `u_1]) (Expr.bvar 2)) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.fluid_bool_hoist_proof then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.fluid_bool_hoist_proof, levelParams := [`u_1], type := Expr.forallE `_ (Expr.sort (Level.param `u_1)) (Expr.forallE `_ (Expr.forallE `_ (Expr.bvar 0) (Expr.sort (Level.zero)) BinderInfo.default) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.bvar 3) BinderInfo.default) (Expr.forallE `_ (Expr.app (Expr.bvar 2) (Expr.app (Expr.bvar 0) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.bvar 3) (Expr.app (Expr.bvar 1) (Expr.const `False [])))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Bool.false then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool.false, levelParams := [], type := Expr.const `Bool [], isUnsafe := false})
  if let none := env.find? `Bool then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Bool, levelParams := [], type := Expr.sort (Level.succ (Level.zero)), isUnsafe := false})
  if let none := env.find? `HasEquiv.Equiv then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `HasEquiv.Equiv, levelParams := [`u, `v], type := Expr.forallE `_ (Expr.sort (Level.param `u)) (Expr.forallE `_ (Expr.app (Expr.const `HasEquiv [Level.param `u, Level.param `v]) (Expr.bvar 0)) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.sort (Level.param `v)) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.clausify_not_iff2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.clausify_not_iff2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.sort (Level.zero)) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.app (Expr.app (Expr.const `Iff []) (Expr.bvar 1)) (Expr.bvar 0))) (Expr.const `False [])) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 2)) (Expr.const `True []))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.sort (Level.zero))) (Expr.bvar 1)) (Expr.const `True []))) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  if let none := env.find? `Duper.equality_factoring_soundness2 then
    env ← ofExceptKernelException $ env.addDecl (Declaration.axiomDecl {name := `Duper.equality_factoring_soundness2, levelParams := [], type := Expr.forallE `_ (Expr.sort (Level.succ (Level.zero))) (Expr.forallE `_ (Expr.bvar 0) (Expr.forallE `_ (Expr.bvar 1) (Expr.forallE `_ (Expr.bvar 2) (Expr.forallE `_ (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 3)) (Expr.bvar 2)) (Expr.bvar 1)) (Expr.app (Expr.app (Expr.const `Or []) (Expr.app (Expr.app (Expr.app (Expr.const `Ne [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 2)) (Expr.bvar 1))) (Expr.app (Expr.app (Expr.app (Expr.const `Eq [Level.succ (Level.zero)]) (Expr.bvar 4)) (Expr.bvar 1)) (Expr.bvar 3))) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default) BinderInfo.default, isUnsafe := false})
  setEnv env